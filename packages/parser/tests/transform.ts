/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
// @ts-nocheck 
import { 
    BinaryExpression,
    ObjectExpression,
    ObjectMethodDefinition,
    ObjectProperty,
    ObjectAccessor,
    PrivateName,
    Program,
    Super,
    Import,
    TemplateElement,
    TemplateLiteral,
    ThisExpression,
    SpreadElement,
    ClassExpression,
    ArrayExpression,
    FunctionExpression,
    ArrorFunctionExpression,
    MetaProperty,
    AwaitExpression,
    NewExpression,
    MemberExpression,
    CallExpression,
    UpdateExpression,
    UnaryExpression,
    ConditionalExpression,
    YieldExpression,
    AssigmentExpression,
    SequenceExpression,
    ObjectPattern,
    ObjectPatternProperty,
    ArrayPattern,
    AssignmentPattern,
    RestElement,
    IfStatement,
    BlockStatement,
    SwitchStatement,
    SwitchCase,
    ContinueStatement,
    BreakStatement,
    ReturnStatement,
    LabeledStatement,
    WhileStatement,
    DoWhileStatement,
    TryStatement,
    CatchClause,
    ThrowStatement,
    WithStatement,
    DebuggerStatement,
    ForStatement,
    ForInStatement,
    ForOfStatement,
    VariableDeclaration,
    VariableDeclarator,
    FunctionBody,
    FunctionDeclaration,
    ClassBody,
    ClassProperty,
    ClassMethodDefinition,
    ClassAccessor,
    ClassDeclaration,
    ImportDeclaration,
    ImportDefaultSpecifier,
    ImportSpecifier,
    ImportNamespaceSpecifier,
    ExportNamedDeclarations,
    ExportSpecifier,
    ExportDefaultDeclaration,
    ExportAllDeclaration,
    TaggedTemplateExpression,
    ChainExpression,
    ClassConstructor,
    SyntaxKinds,
    Visitor, 
    SytaxKindsMapLexicalLiteral,
    traversal,
    ExpressionStatement,
    BoolLiteral,
    UndefinbedLiteral,
    EmptyStatement,
    RegexLiteral,
    ModuleItem,
} from "emcakit-jscommon";

const VisitorTable: Visitor = {
    [SyntaxKinds.Program]: transformKind,
    [SyntaxKinds.RegexLiteral]: transformKind,
    [SyntaxKinds.BooleanLiteral]: transformKind,
    [SyntaxKinds.NullLiteral]: transformKind,
    [SyntaxKinds.UndefinedLiteral]: transformKind,
    [SyntaxKinds.NumberLiteral]: transformKind,
    [SyntaxKinds.StringLiteral]: transformKind,
    [SyntaxKinds.Identifier]: transformKind,
    [SyntaxKinds.Super]: transformKind,
    [SyntaxKinds.Import]: transformKind,
    [SyntaxKinds.ThisExpression]: transformKind,
    [SyntaxKinds.PrivateName]: transformKind,
    [SyntaxKinds.TemplateLiteral]: transformKind,
    [SyntaxKinds.TemplateElement]: transformKind,
    [SyntaxKinds.ObjectExpression]: transformKind,
    [SyntaxKinds.ObjectProperty]: transformKind,
    [SyntaxKinds.ObjectMethodDefintion]: transformKind,
    [SyntaxKinds.ObjectAccessor]: transformKind,
    [SyntaxKinds.SpreadElement]: transformKind,
    [SyntaxKinds.ClassExpression]: transformKind,
    [SyntaxKinds.ArrayExpression]: transformKind,
    [SyntaxKinds.FunctionExpression]: transformKind,
    [SyntaxKinds.ArrowFunctionExpression]: transformKind,
    [SyntaxKinds.MetaProperty]: transformKind,
    [SyntaxKinds.AwaitExpression]: transformKind,
    [SyntaxKinds.NewExpression]: transformKind,
    [SyntaxKinds.MemberExpression]: transformKind,
    [SyntaxKinds.CallExpression]: transformKind,
    [SyntaxKinds.TaggedTemplateExpression]: transformKind,
    [SyntaxKinds.ChainExpression]: transformKind,
    [SyntaxKinds.UpdateExpression]: function UpdateExpression(node: UpdateExpression) {
        node.kind = SytaxKindsMapLexicalLiteral[SyntaxKinds.UpdateExpression];
        node.operator = SytaxKindsMapLexicalLiteral[node.operator];
    },
    [SyntaxKinds.UnaryExpression]: function UnaryExpression(node: UnaryExpression) {
        node.kind = SytaxKindsMapLexicalLiteral[SyntaxKinds.UnaryExpression];
        node.operator = SytaxKindsMapLexicalLiteral[node.operator];
    },
    [SyntaxKinds.BinaryExpression]: function BinaryExpression(node: BinaryExpression) {
        node.kind = SytaxKindsMapLexicalLiteral[SyntaxKinds.BinaryExpression];
        node.operator = SytaxKindsMapLexicalLiteral[node.operator];
    },
    [SyntaxKinds.ConditionalExpression]: transformKind,
    [SyntaxKinds.YieldExpression]: transformKind,
    [SyntaxKinds.AssigmentExpression]: function AssignmentExpression(node: AssigmentExpression) {
        node.kind = SytaxKindsMapLexicalLiteral[SyntaxKinds.AssigmentExpression];
        node.operator = SytaxKindsMapLexicalLiteral[node.operator];
    },
    [SyntaxKinds.SequenceExpression]: transformKind,
    [SyntaxKinds.ExpressionStatement]: transformKind,
    [SyntaxKinds.ObjectPattern]: transformKind,
    [SyntaxKinds.ObjectPatternProperty]: transformKind,
    [SyntaxKinds.ArrayPattern]: transformKind,
    [SyntaxKinds.AssignmentPattern]: transformKind,
    [SyntaxKinds.RestElement]: transformKind,
    [SyntaxKinds.IfStatement]: transformKind,
    [SyntaxKinds.BlockStatement]: transformKind,
    [SyntaxKinds.DebuggerStatement]: transformKind,
    [SyntaxKinds.EmptyStatement]: transformKind,
    [SyntaxKinds.SwitchStatement]: transformKind,
    [SyntaxKinds.SwitchCase]: transformKind,
    [SyntaxKinds.ContinueStatement]: transformKind,
    [SyntaxKinds.BreakStatement]: transformKind,
    [SyntaxKinds.ReturnStatement]: transformKind,
    [SyntaxKinds.LabeledStatement]: transformKind,
    [SyntaxKinds.WhileStatement]: transformKind,
    [SyntaxKinds.DoWhileStatement]: transformKind,
    [SyntaxKinds.TryStatement]: transformKind,
    [SyntaxKinds.CatchClause]: transformKind,
    [SyntaxKinds.ThrowStatement]: transformKind,
    [SyntaxKinds.WithStatement]: transformKind,
    [SyntaxKinds.DebuggerStatement]: transformKind,
    [SyntaxKinds.ForStatement]: transformKind,
    [SyntaxKinds.ForInStatement]: transformKind,
    [SyntaxKinds.ForOfStatement]: transformKind,
    [SyntaxKinds.VariableDeclaration]: transformKind,
    [SyntaxKinds.VariableDeclarator]: transformKind,
    [SyntaxKinds.FunctionBody]: transformKind,
    [SyntaxKinds.FunctionDeclaration]: transformKind,
    [SyntaxKinds.ClassBody]: transformKind,
    [SyntaxKinds.ClassProperty]: transformKind,
    [SyntaxKinds.ClassMethodDefinition]: transformKind,
    [SyntaxKinds.ClassConstructor]: transformKind,
    [SyntaxKinds.ClassAccessor]: transformKind,
    [SyntaxKinds.ClassDeclaration]: transformKind,
    [SyntaxKinds.ImportDeclaration]: transformKind,
    [SyntaxKinds.ImportDefaultSpecifier]: transformKind,
    [SyntaxKinds.ImportSpecifier]: transformKind,
    [SyntaxKinds.ImportNamespaceSpecifier]: transformKind,
    [SyntaxKinds.ExportNamedDeclaration]: transformKind,
    [SyntaxKinds.ExportSpecifier]: transformKind,
    [SyntaxKinds.ExportDefaultDeclaration]: transformKind,
    [SyntaxKinds.ExportAllDeclaration]: transformKind,
    [SyntaxKinds.JSXElement]: transformKind,
    [SyntaxKinds.JSXOpeningElement]: transformKind,
    [SyntaxKinds.JSXClosingElement]: transformKind,
    [SyntaxKinds.JSXIdentifier]: transformKind,
    [SyntaxKinds.JSXMemberExpression]: transformKind,
    [SyntaxKinds.JSXNamespaceName]: transformKind,
    [SyntaxKinds.JSXAttribute]: transformKind,
    [SyntaxKinds.JSXSpreadAttribute]: transformKind,
    [SyntaxKinds.JSXSpreadChild]: transformKind,
    [SyntaxKinds.JSXExpressionContainer]: transformKind,
    [SyntaxKinds.JSXFragment]: transformKind,
    [SyntaxKinds.JSXOpeningFragment]: transformKind,
    [SyntaxKinds.JSXClosingFragment]: transformKind,
};
function transformKind(node: ModuleItem) {
    node.kind = SytaxKindsMapLexicalLiteral[node.kind]
}
export function transformSyntaxKindToLiteral(program: Program): void {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    traversal(program, VisitorTable);
}